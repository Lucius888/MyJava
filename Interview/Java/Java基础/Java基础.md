## 面向对象和面向过程的区别

- **面向过程** ：**面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展。** 
- **面向对象** ：**面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**。

> 这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码。
>
> 而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比Java好。

##  JVM 、JDK 、JRE

### JVM

Java虚拟机（JVM）是运行 Java 字节码的虚拟机。保证 了java跨平台的特性。

**什么是字节码?采用字节码的好处是什么?**

> 在 Java 中，JVM可以理解的代码就叫做`字节码`（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。效率高，跨平台！

**Java 程序从源代码到运行一般有下面3步：**

![Java程序运行过程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png)

### JVM的类加载机制

将.class文件加载到内存中是由ClassLoader和其子类实现的。类的加载分为**隐式记载**和**显式加载**。隐式加载就是程序使用new新建一个对象时，会隐式的调用类加载器把对应的类加载到JVM中。显示加载指的是直接调用class.forName()方法将类加载到JVM中

### JDK 和 JRE

JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。

JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。

如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装JDK了。

## Java和C++的区别?

- 都是面向对象的语言，都支持封装、继承和多态
- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理机制，不需要程序员手动释放无用内存

## java中的栈与堆

栈：基本数据类型和对象的引用变量都存放于栈中，变量出了作用域就会自动释放

堆：存放运行时创建的对象（new出来的都在堆）。堆中的对象没有任何引用(就是在栈中没有任何一个变量指向该对象)时会被GC回收。

## 字符型常量（char）和字符串常量(string)的区别

- 形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符
- 含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)
- 占内存大小：字符常量只占2个字节; 字符串常量占若干个字节(至少一个字符结束标志) (**注意： char在Java中占两个字节**)

![参考-JavaGuide](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg)

## 类型转换

- 自动向上转型，强制向下转型（精度丢失）
- 基本数据类型不能与boolean相互转换
- 设计byte、short和char类型运算时会自动转为int，因此结果也是int类型

## 字节(byte)和字符(char)的区别

字节是存储容量的基本单位，字符是数子，字母，汉子以及其他语言的各种符号。1字节=8个二进制单位：一个一个字符由一个字节或多个字节的二进制单位组成。

## char 型变量中能不能存贮一个中文汉字?为什么?

- char 型变量是用来存储 Unicode 编码的字符的，unicode 编码字符集中包含了汉字，所以，char 型变量 中当然可以存储汉字啦。
- 如果某个特殊的汉字没有被包含在 unicode 编码字符集中，那么，这个 char 型变量中就不能存储这个特殊汉字。
- unicode 编码占用两个字节，所以，char 类型的变量也是占 用两个字节。

## 自动装箱与拆箱

- **装箱**：将基本数据类型转换为包装类型；
- **拆箱**：将包装类型转换为基本数据类型；

## int和Integer的区别

- Integer是int的包装类，int则是java的一种基本数据类型 
- Integer变量必须实例化后才能使用，而int变量不需要 
- **Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象**；而int则是直接存储数据值 
- Integer的默认值是null，int的默认值是0

延伸： 
关于Integer和int的比较 
1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。

```
Integer i = new Integer(100);
Integer j = new Integer(100);
System.out.print(i == j); //false
```

2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）

```
Integer i = new Integer(100);
int j = 100；
System.out.print(i == j); //true
```

3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）

```
Integer i = new Integer(100);
Integer j = 100;
System.out.print(i == j); //false
```

4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false

```
Integer i = 100;
Integer j = 100;
System.out.print(i == j); //true
Integer i = 128;
Integer j = 128;
System.out.print(i == j); //false
```

对于第4条的原因： 
java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：

```
public static Integer valueOf(int i){
    assert IntegerCache.high >= 127;
    if (i >= IntegerCache.low && i <= IntegerCache.high){
        return IntegerCache.cache[i + (-IntegerCache.low)];
    }
    return new Integer(i);
}
```

java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了

## Java 面向对象编程三大特性: 封装 继承 多态

### 封装

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。（

==在内部完成数据和操作方法的绑定，对外只提供被调用的接口==

### 继承

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

**关于继承如下 3 点请记住：**

1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。

### 多态

所谓多态就是==允许不同子类型的对象对同一个方法做出不同的响应==

Java中多态的两种表现形式：==重写和重载==



**多态存在要有3个必要条件：继承、方法重写、父类引用指向子类对象。**

## 组合和继承

- 都是对代码进行复用的方式
- 组合是（has-a 关系），继承是（is-a 关系）[车属于机动车(is-a)，车有轮胎（has-a）]
- 尽可能使用组合和接口的方式，而避免使用继承，这样程序具有更好的扩展性

## 重载和重写的区别

### 重载

- 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同
- 不能通过 方法的访问权限、返回值类型和抛出的异常来进行重载



### 重写

 子类重新定义了父类的方法，发生在继承或实现关系的类中

- 方法名、参数列表必须相同，返回值范围和抛出的异常范围小于等于父类
- 访问修饰符范围大于等于父类。
- 不能够重写一个private或者是static修饰的方法（重写是运行时动态绑定，static是编译器就已经处理好的）

## 一个类的构造函数的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?

主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。

## 构造函数有哪些特性？

- 名字与类名相同。
- 没有返回值，但不能用void声明构造函数。
- 生成类的对象时自动执行，无需调用。

## 初始化优先级

- 静态对象（变量）优先于非静态对象（变量）

- 父类优先于子类

- 按成员变量的定义顺序进行初始化

    **具体加载顺序。**

    - (1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)
    - (2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )
    - (3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )
    - (4) 父类构造函数
    - (5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )
    - (6) 子类构造函数



## 在 Java 中定义一个不做事且没有参数的构造方法的作用

Java 程序在执行子类的构造方法之前，如果没有用 `super() `来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 `super() `来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。

## 构造器 Constructor 是否可被 override?

父类的私有属性和构造方法并不能被继承，所以 Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。

## String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?不可变有什么好处？

**可变性**

简单的来说：String 类中**使用 final 关键字修饰字符数组来保存字符串**，`private　final　char　value[]`，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串`char[]value` 但是没有用 final 关键字修饰，所以这两种对象都是可变的。

**线程安全性**

String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类。StringBuffer **对方法加了同步锁或者对调用的方法加了同步锁**，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。　

**性能**

每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。

**对于三者使用的总结：** 

1. 操作少量的数据: 适用String
2. 单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer

 **不可变的好处**

- 提高效率，string的不可变保证了常量池中数据安全，因此可以无需反复创建相同对象，直接引用即可 
- 安全，string常被用来表示文件路径、url
- string不可变则保证hashcode不可变，无需反复计算



## String Pool

字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。

当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。

下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。

```java
String s1 = new String("aaa");
String s2 = new String("aaa");
System.out.println(s1 == s2);           // false
String s3 = s1.intern();
String s4 = s1.intern();
System.out.println(s3 == s4);           // true
```

如果是采用 "bbb" 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。

```java
String s5 = "bbb";
String s6 = "bbb";
System.out.println(s5 == s6);  // true
```

在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。

## String中的“+”是如何实现的？

在底层中通过调用StringBuilder的append()方法实现的

## 在一个静态方法内调用一个非静态成员为什么是非法的?

**由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。**



## 接口和抽象类

**抽象类** ：如果一个类里面包含抽象方法那么这个类就是一个抽象类，使用关键字abstract修饰一个抽象方法，抽象方法没有方法体。

**接口** ：一个方法的集合，接口中的所有方法都没有方法体，使用interface声明

**共同点**

- 都不能够被实例化
- 接口的的实现类和抽象类的子类都只有在实现了接口和抽象类的方法后才能够被实例化

**区别**

- 接口方法默认修饰符是public abstract，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。 

- 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。

- 接口强调功能的实现（has-a的关系），抽象类强调所属关系（is-a的关系）

备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。

1. Java抽象类可以有构造函数吗？
    可以有，抽象类可以声明并定义构造函数。因为你不可以创建抽象类的实例，所以构造函数只能通过构造函数链调用（Java中构造函数链指的是从其他构造函数调用一个构造函数），例如，当你创建具体的实现类。现在一些面试官问，如果你不能对抽象类实例化那么构造函数的作用是什么？好吧，它可以用来初始化抽象类内部声明的通用变量，并被各种实现使用。另外，即使你没有提供任何构造函数，编译器将为抽象类添加默认的无参数的构造函数，没有的话你的子类将无法编译，因为在任何构造函数中的第一条语句隐式调用super()，Java中默认超类的构造函数。
2. Java抽象类可以实现接口吗？它们需要实现所有的方法吗？
    可以，抽象类可以通过使用关键字implements来实现接口。因为它们是抽象的，所以它们不需要实现所有的方法。好的做法是，提供一个抽象基类以及一个接口来声明类型 。这样的例子是，java.util.List接口和相应的java.util.AbstractList抽象类。因为AbstractList实现了所有的通用方法，具体的实现像LinkedList和ArrayList不受实现所有方法的负担，它们可以直接实现List接口。这对两方面都很好，你可以利用接口声明类型的优点和抽象类的灵活性在一个地方实现共同的行为。
3. Java抽象类可以是final的吗？
    不可以，Java抽象类不能是final的。将它们声明为final的将会阻止它们被继承，而这正是使用抽象类唯一的方法。它们也是彼此相反的，关键字abstract强制继承类，而关键字final阻止类被扩张。在现实世界中，抽象表示不完备性，而final是用来证明完整性。底线是，你不能让你的Java类既abstract又final，同时使用，是一个编译时错误。
4. Java抽象类可以有static方法吗？
    可以，抽象类可以声明并定义static方法，没什么阻止这样做。但是，你必须遵守Java中将方法声明为static的准则，
5. 抽象类必须有抽象方法吗？
    不需要，抽象类有抽象方法不是强制性的。你只需要使用关键字abstract就可以将类声明为抽象类。编译器会强制所有结构的限制来适用于抽象类，例如，现在允许创建一些实例。是否在抽象类中有抽象方法是引起争论的。我的观点是，抽象类应该有抽象方法，因为这是当程序员看到那个类并做假设的第一件事。这也符合最小惊奇原则。
6. 何时选用抽象类而不是接口？
    当子类和父类在逻辑上存在明显的逻辑结构的时候
7. Java中的抽象方法是什么？
    抽象方法是一个没有方法体的方法。你仅需要声明一个方法，不需要定义它并使用关键字abstract声明。Java接口中所有方法的声明默认是abstract的。这是抽象方法的例子
    public void abstract printVersion();
    现在，为了实现这个方法，你需要继承该抽象类并重载这个方法。
8. Java抽象类中可以包含main方法吗？
    是的，抽象类可以包含main方法，它只是一个静态方法，你可以使用main方法执行抽象类，但不可以创建任何实例。

## 成员变量与局部变量的区别有哪些？

1. 从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。
2. 从变量在内存中的存储方式来看:如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
3. 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

## 静态方法和实例方法有何不同

1. 静态方法可以无需创建对象就可以调用，使用"类名.方法名"的方式。而实例方法使用"对象名.方法名"的方式。
2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。

## 对象的相等与指向他们的引用相等,两者有什么不同?

对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。

## == 与 equals

**==** : 基本数据类型比较的是值，引用数据类型比较的是内存地址。

**equals()** : 只能用于比较引用类型，比较的是引用对象的内存地址是否相同。但它一般有两种使用情况：

-  情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
-  情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

**举个例子：**

```java
public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为一个引用
        String b = new String("ab"); // b为另一个引用,对象的内容一样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
            System.out.println("aa==bb");
        if (a == b) // false，非同一对象
            System.out.println("a==b");
        if (a.equals(b)) // true
            System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
```

**说明：**

- String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
- 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。

## hashCode 与 equals (重要)

面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”

### hashCode（）介绍

hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。

### 为什么要有 hashCode

**我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：** 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 `equals()`方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。

通过我们可以看出：`hashCode()` 的作用就是**获取哈希码**，也称为散列码；它实际上是返回一个int整数。这个**哈希码的作用**是确定该对象在哈希表中的索引位置。**`hashCode() `在散列表中才有用，在其它情况下没用**。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。

### hashCode（）与equals（）的相关规定

1. 如果两个对象相等，则hashcode一定也是相同的
3. 两个对象的hashcode值相等，它们也不一定是相等的
4. **equals 方法被覆盖过，则 hashCode 方法也必须被覆盖**。因为在散列表中如果重写了equals方法让两个对象相等，那么表中就会出现重复元素违反规定。（表中对象的插入是判断对象的hashcode）

## final 关键字

final关键字主要用在三个地方：变量、方法、类。

1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
3. 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。
3. 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。

**Final修饰有啥好处**

- final的关键字提高了性能，JVM和java应用会缓存final变量；
- final变量可以在多线程环境下保持线程安全；
- 使用final的关键字提高了性能，JVM会对方法变量类进行优化；

## static 关键字

**static 关键字主要有以下四种使用场景：**

1. **修饰成员变量和成员方法:** 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：`类名.静态变量名`    `类名.静态方法名()`
2. **静态代码块:** 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
3. **静态内部类（static修饰类的话只能修饰内部类）：** 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。

## this 关键字

this用于指向当前的实例对象，非常重要的作用就是用于区别对象的成员变量和方法的形参

```java
class People{
    String name;
    //true
    public People(String name){
        this.name=name;
    }
    //false
    public People(String name){
        name=name;
    }
}
```



## super 关键字

super关键字用于从子类访问父类的变量和方法。 例如：

```java
public class Super {
    protected int number;
     
    protected showNumber() {
        System.out.println("number = " + number);
    }
}
 
public class Sub extends Super {
    void bar() {
        super.number = 10;
        super.showNumber();
    }
}
```

在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 `showNumber（）` 方法。

**使用 this 和 super 要注意的问题：**

- 在构造器中使用 `super（）` 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
- this、super不能用在static方法中。

**简单解释一下：**

被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， **this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西**。

## public，private，protected作用域 

|  作用域   | 当前类 | 当前包 | 子类 | 其他包 |
| :-------: | :----: | :----: | :--: | :----: |
|  public   |   √    |   √    |  √   |   √    |
| protected |   √    |   √    |  √   |   ×    |
|  default  |   √    |   √    |  ×   |   ×    |
|  private  |   √    |   ×    |  ×   |   ×    |

## Java 中的异常处理

在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 **Throwable类**。Throwable： 有两个重要的子类：**Exception（异常）** 和 **Error（错误）**。

**Error（错误）:是程序无法处理的错误**，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。

**Exception（异常）:是程序本身可以处理的异常**。

- 检查异常：所有继承于Exception且不属于运行时异常都属于检查异常。发生在编译器，并不会导致程序出错，但是java编译器强制要求要去主动捕获这类异常并进行处理。
- 运行时异常：没有要求进行捕获，没有处理的时候由JVM处理，并向上抛出直到找到处理代码。
    - **NullPointerException**（空指针异常） 
    - **ArrayIndexOutOfBoundsException** （数组越界异常）
    - **ArrayStoreException** （数组存储异常）
    - **ClssCastException**(类型转换异常)
    - **ArithmeticException**（算术运算异常，一个整数除以0时，抛出该异常）和
    - **BufferOverflowException**(缓冲区溢出异常)

### Throwable类常用方法

- **public string getMessage()**:返回异常发生时的简要描述
- **public string toString()**:返回异常发生时的详细信息
- **public string getLocalizedMessage()**:返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同
- **public void printStackTrace()**:在控制台上打印Throwable对象封装的异常信息

### 异常处理总结

- **try 块：** 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。
- **catch 块：** 用于处理try捕获到的异常。
- **finally 块：** 无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return
    语句时，finally语句块将在方法返回之前被执行。
- 先捕获子类异常，再捕获基类异常
- 尽早的抛出异常
- 可以根据实际需求自定义异常，这些异常继承于Exception类

**在以下4种特殊情况下，finally块不会被执行：**

1. 在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行
2. 在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行
3. 程序所在的线程死亡。
4. 关闭CPU。

**注意：** 当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。如下：

```java
    public static int f(int value) {
        try {
            return value * value;
        } finally {
            if (value == 2) {
                return 0;
            }
        }
    }
```

如果调用 `f(2)`，返回值将是0，因为finally语句的返回值覆盖了try语句块的返回值。

### final, finally, finalize 的区别。

- final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 内部类要访问局部变量，局部变量必须定义成 final 类型
- finally 是异常处理语句结构的一部分，表示总是执行。在return之前执行的，如果 finally 里有 return 语句，则覆盖 try/catch 里的 return 。
- finalize 是 Object 类的一个protected方法，在垃圾收集器执行的时候会调用被回收对象的此方法， 可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM 不保证此方法总被调用

## switch语句能否作用在byte上，能否作用在long上，能否作用在String上？

- switch的condition只能是一个整数表达式或者枚举常量
- 整数表达式则是int或者integet包装类型，由于，byte，short，char都可以隐式转换为int，则作用。
- long 和 String 类型都不符合 switch 的语法规定，并且不能被隐式转 换成 int 类型，所以，它们不能作用于 swtich 语句中。



## 获取用键盘输入常用的两种方法

方法1：通过 Scanner

```java
Scanner input = new Scanner(System.in);
String s  = input.nextLine();
input.close();
```

方法2：通过 BufferedReader 

```java
BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); 
String s = input.readLine(); 
```

## Java 中 IO 流

### Java 中 IO 流分为几种?

   - 字节流：以字节为单位（8bit）,不会用到缓存；继承于InputStream和OutputStream
   - 字符流：以字符为单位（16bit）,用到缓存；继承于Reader和Writer

### 既然有了字节流,为什么还要有字符流?

问题本质想问：**不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？**

回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

### BIO,NIO,AIO 有什么区别?

- **BIO (Blocking I/O):** 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
- **NIO (New I/O):** NIO是一种同步非阻塞的I/O模型**，面向缓冲的，以块的方式处理数据**，因此处理速度更快。基于通道的双向I/O操作方法。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发
- **AIO (Asynchronous I/O):** AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。

### Java 如何进行文件读取？

FileReader类是将文件按字符流的方式读取char数组或者String.FileInputStream则按字符流的方式读取文件byte数组。

- 1.首先获得一个文件句柄。 File fille= new File();file即为文件句柄。两人之间连
    通电话网络了。接下来可以开始打电话了
- 2.通过这条线路读取甲方的信息: new FileInputStream(fe)目前这个信息已经
    读进来内存当中了。接下来需要解读成乙方可以理解的东西
- 3.既然你使用了 FileInputStream()。那么对应的需要使用 InputStreamReader()
    这个方法进行解读刚才装进来内存当中的数据
- 4.解读完成后要输出呀。那当然要转换成IO可以识别的数据呀。那就需要调用字节
    码读取的方法 Bufferedreader()。同时使用 bufferedReader()的 readline()方
    法读取txt文件中的每一行数据哈。

## Java 序列化

序列化是一种将对象以一连串的字节描述的过程，用于解决在对对象流进行读写操作所引发的问题。

序列化可以将对象的状态写在流里进行网络传输，或者保存在文件/数据库等系统中，并在需要时把流读取出来重新构造一个相同的对象。

### 使用场景

- 需要使用网络进行传输，或对象的状态需要被持久化到文件或数据库中
- 序列化能够实现深拷贝，即可以对对象的引用也进行复制

```java
//序列化一个对象，并将它发送到输出流。
public final void writeObject(Object x) throws IOException
//从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。
public final Object readObject() throws IOException, ClassNotFoundException
```

注意事项

- 序列化必须实现 java.io.Serializable 接口。
- 被序列化的类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须使用transient修饰，transient只能修饰变量，不能修饰类和方法。

## 深拷贝 vs 浅拷贝

1. **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，实际两者引用的还是同一个对象，改变其一另外一个也会变，此为浅拷贝。实现方法，重写clone。
2. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。此时两者都已经不是同一个对象了。
    - 实现方法：1.重写clone，但是注意要对每一层引用的对象都重写clone。2.序列化再反序列化，形成两个对象。

![deep and shallow copy](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/java-deep-and-shallow-copy.jpg)

## 值传递与引用传递

值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。

引用传递：指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

==除了八种基本数据类型是值传递，其他都是引用传递==

### 为什么Java中只有值传递

==在java中：基本类型传递的是值的副本，引用类型传递的是地址的副本，都不会影响原始对象，因此自然就属于值传递==

- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。
- 一个方法不能让对象参数引用一个新的对象。

## String A = "123"; String B = new String("123");生成几个对象？

如果常量池中原来没有“123”那么就是生成了2个对象，如果常量池中有“123”那么只要1个对象生成

## 说说&和&&的区别

- &和&&都可以用作逻辑与的运算符，表示逻辑与（and）
- 当运算符两边的表达式的结果都为 true 时， 整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。
- &&还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式
- &还可以用作位运算符，当&操作符两边的表达式不是 boolean 类型时，&表示按位与操作，我们通常 使用 0x0f 来与一个整数进行&运算，来获取该整数的最低 4 个 bit 位

## Comparable 和 Comparator

- Comparable 是排序接口， 位于java.lang包下，接口仅仅只包括一个 compareTo()方法；类内排序，只要实现类了compareable接口就能够使用默认的方法进行排序。
- Comparator 是比较器接口， 位于java.util包下，接口里有两个方法compare()和equals()。类外排序，当类本身不支持排序(即没有实现Comparable接口)，那么我们可以建立一个“该类的比较器”来进行排序。这个“比较器”只需要实现Comparator接口即可。

## 泛型

- 基本概念：参数化类型，通过类型擦除实现（编译器在编译时擦除了所有类型相关的信息）
- 优点：避免了复杂饿类型转换，提供了编译期的类型安全
- 通配符
    - 非限定通配符 ：``<?>``可用任意类型来代替
    - 限定通配符：`<? extent T> `确保必须是T的子类``<T super ?> `确保是T的父类
- Araay是不允许使用泛型的

## 反射

### 反射机制介绍

**Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能成为java语言的反射机制。**

### 获取Class对象的3种方式

- 类名.Class
- 实例.getClass()
- `Class.forName()`

### 创建对象的4种方式

- new实例化对象

    使用new关键字创建对象应该是最常见的一种方式，但我们应该知道，使用new创建对象会增加耦合度。无论使用什么框架，都要减少new的使用以降低耦合度。

- 反射机制创建对象

    使用Class类的newInstance方法

- clone方法创建对象

    clone时，需要已经有一个分配了内存的源对象，创建新对象时，首先应该分配一个和源对象一样大的内存空间。要调用clone方法需要实现Cloneable接口

- 反序列化创建对象

    使用序列化时，要实现实现Serializable接口，将一个对象序列化到磁盘上，而采用反序列化可以将磁盘上的对象信息转化到内存中。

### 静态编译和动态编译

- 静态编译：在编译时确定类型，绑定对象
- 动态编译：运行时确定类型，绑定对象

### 反射机制优缺点

- 优点：运行期间类型的判断，动态加载类，提高代码的灵活度。
- 缺点：开销大；安全限制，使用反射必须在一个没有安全限制的环境中运行；内部暴露；

### 反射的应用场景

**反射是框架设计的灵魂**

在我们平时的项目开发过程中，基本上很少会直接使用的反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如**模块化**的开发，通过反射去调用对应的字节码；动态代理设计模型也采用了反射机制，还有我们日常使用的**Spring / Hibernate**等框架也大量使用到了反射机制。

- 我们在使用JDBC连接数据库时使用`Class.forName()`通过反射加载数据看的驱动程序；
- Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring通过XML配置模式装载Bean的过程；
    - 将程序内所有XML或Properties配置文件加载入内存中；
    - Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息；
    - 使用反射机制，根据这个字符串获得某个类的Class实例
    - 动态配置实例的属性

## 静态代理、动态代理、cglib代理

### 静态代理

- 在编译器就确定了代理对象，在程序运行之前就已经存在了
- 非入侵的对目标对象进行功能扩展，代理类和目标类需要实现相同的接口。存在大量重复的代码，增加了代码维护的复杂度。

###  动态代理

![image-20200705152032289](C:\Users\Lucius\AppData\Roaming\Typora\typora-user-images\image-20200705152032289.png)

- 在运行期间通过反射机制动态的生成代理类
- 使用动态代理的核心就是**InvocationHandler（接口）和Proxy（类）**
- 使用Proxy.newProxyInstance创建一个代理类对象
- InvocationHandler的核心就是动态代理处理程序：invoke方法，involke会返回我们我们想要的结果。
- 动态代理避免了大量的重复代码，但是由于用到反射也增加了开销



### CGLIB(Code Generation Library)代理

前两种代理模式都需要目标对象实现一个接口，但是当目标对象没有接口的时候怎么办？

cglib是针对类来实现代理的，他的原理是利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理，覆盖其中方法实现增强，但因为采用的是继承，所以不能对`final修饰`的类进行代理。

## ArrayList和LinkedList的区别？

- ArrayList底层是数组，ArrayLIst查找数据快，线程不安全
- LinkedList底层是链表，LinkedList插入删除快，线程不安全
- ArrayList取代Vector的原因是，vector是线程安全的但带来的后果是会在同步操作上耗费大量时间。

## ArrayList扩容机制

### ArrayList三种构造方法

- 如果不传入初始容量，使用默认容量：10
- 传入初始容量，不为零就创建这个初始容量大小的数组，为零就是一个空数组
- 如果传入的是一个`Collecttion`，则会调用`toArray()`方法把它变成一个数组，然后判断大小和第二种方法处理方式一样。

### 扩容机制

**默认情况下，新的容量会是原容量的1.5倍，这里用了位运算提高效率**。一般情况下，如果扩容1.5倍后就大于期望容量，那就返回这个1.5倍旧容量的值。而如果小于期望容量，那就返回期望容量。

**使用1.5倍这个数值而不是直接使用期望容量，是为了防止频繁扩容影响性能**。

### ArrayList有缩容吗？

`ArrayList`没有缩容。无论是`remove`方法还是`clear`方法，它们都不会改变现有数组`elementData`的长度。但是它们都会把相应位置的元素设置为`null`，以便垃圾收集器回收掉不使用的元素，节省内存。

## LinkedList可以用for循环遍历吗？

- 能不用尽量不要用，linkedList底层是链表，它使用for进行遍历，访问每一个元素都是从头开始访问然后直到找到这个元素，
- 比如说找第三个节点，需要先找到第一个节点然后找到第二个节点；
- 继续找第4个节点，不是从第三个节点开始找的，还是从第一个节点开始，所以非常的慢，不推荐，可以用迭代器进行遍历。

## HashTable和HashMap

- Hashtable的方法是安全的有synchronized修饰，Hashmap是不安全的；
- hashtable不可以有null值；HashMap则可以有空值；
- Hashtable中数组默认大小是11，扩容的时候hashtable是乘以2加1。Hashmap默认大小是16，扩容hashmap是乘以2，负载因子0.75.
- **底层数据结构：** JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。

### HashMap为什么线程不安全

他并没有ConcurrentHashMap 的那种分段锁机制。例如当有两个线程同时对一个entry进行put操作时，都会获取到头节点，这样显然有问题。又比如在扩容的时候，两个线程都执行resize，各自生成新的数组并重新计算下标，这也是有问题的

### HashMap 的长度为什么是2的幂次方

为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。数组下标的计算方法原理是hash对数组的长度取模运算得到的余数才能用来要存放的位置。取模自然使用%，但是二进制操作更加有效率，公式： `(n - 1) & hash`。（n代表数组长度）。保证n-1之后末位全是1，但是碰撞依旧严重。

### 扰动函数

- hash值与右移16位的hash做异或运算，得到经过扰动函数后的hash
- 右移16位正好为32bit的一半，自己的高半区和低半区做异或，是为了混合原始哈希吗的高位和低位，来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，使高位的信息也被保留下来



## ConcurrentHashMap 和 Hashtable

ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。

- **底层数据结构：** JDK1.7的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用数组+链表/红黑树。Hashtable 的底层数据结构都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；
- **实现线程安全的方式（重要）：** ① **在JDK1.7的时候，ConcurrentHashMap（分段锁）** 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 **到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② **Hashtable(同一把锁) :使用 synchronized 来保证线程安全，会产生阻塞，效率非常低下。



## 设计模式

常见的设计模式有工厂模式、单例模式、迭代器模式、享元模式和观察者模式

### 单例模式

- 单例模式：确保某一个类只有一个实例，而且自行实例化，并向整个系统提供这个实例单例模式。

**单例类的构造函数必须为私有，同时单例类必须提供一个全局访问点。**

其中类变量uniqueInstance持有唯一的单例实例，类方法getInstance()来获取唯一的实例化对象

```java
//单例模式的简单实现
public class Test{
    private Test(){}
    private static Test uniqueInstance = new Test();
    private static Test getInstace(){
        return uniqueInstance;
    }
}
```



#### 单例模式与全局变量的区别

- 全局变量是对一个对象的静态引用，无法保证应用程序只有一个实例
- 全局变量会造成程序可读性变差
- 全局变量无法继承



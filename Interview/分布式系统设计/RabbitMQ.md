## 消息队列

消息队列中间件是分布式系统中重要的组件，主要解决应用解耦，异步处理，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。目前使用较多的消息队列有RocketMQ，RabbitMQ，ZeroMQ，MetaMQ，Kafka
两种消费模型

- 点对点模型（一条消息被一个消费者使用）：同步的
- 发布/订阅模型（一条消息被多个消费者使用）：异步的

###  消息队列的应用场景（优点）

#### 流量削峰

用户请求数量暴增，远远大于系统的处理能力（实际上就是数据库的访问能力，一般为1秒2k次数），这种情况系统就会崩溃。解决方法就是使用消息队列，用户的请求都被挤压在MQ中，系统仍然是按照最大速度去MQ中拉取消息，直到把全部消息处理完毕。

#### 应用解耦

使用MQ中间件，那么A就只需要向MQ中发送消息，不用管有没有去消费，再增加或者减少一个消费者的时候也比较方便。

#### 异步处理

发送者将消息发送给消息队列之后，不需要**同步等待**消息接收者处理（B/C/D）完毕，而是从MQ立即返回进行其它操作。

### 消息队列的缺点

#### 系统可用性降低

系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，ABCD 四个系统还好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整？MQ 一挂，整套系统崩溃，你不就完了？

#### 系统复杂度提高

硬生生加个 MQ 进来，复杂度提高了。

## RabbitMQ 结构模型

- **ConnectionFactory（连接管理器）**：应用程序与Rabbit之间建立连接的管理器，程序代码中使用；
- **Channel（信道）**：消息推送使用的通道；
- **Exchange（交换器）**：用于接受、分配消息；
- **Queue（队列）**：用于存储生产者的消息；
- **RoutingKey（路由键**）：用于把生成者的数据分配到交换器上；
- **BindingKey（绑定键**）：用于把交换器的消息绑定到队列上；
    ![image-20200613093935131](C:\Users\Lucius\AppData\Roaming\Typora\typora-user-images\image-20200613093935131.png)

#### Exchange类型

- **direct exchange**
根据消息的 route key 来将消息分发到相对应的queue 中
- **fanout exchange**
将消息分发给所有绑定到此 exchange 的 queue 中
- **topic exchange**
根据 route key 将消息分发到与此消息的 route key 相匹配的并且绑定到此 exchagne 中的 queue 中

- **header exchange**
不使用 route key 作为路由的依据, 而是使用消息头属性来路由消息.



### rabbitmq 的消息是怎么发送的？



首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证，客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。



### rabbitmq 怎么保证消息的稳定性？

- 提供了事务的功能。
- 通过将 channel 设置为 confirm（确认）模式。

### rabbitmq 怎么避免消息丢失？

- 消息持久化

- ACK确认机制

- 设置集群镜像模式

- 消息补偿机制

    

### rabbitmq 持久化有什么缺点？

持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。

### rabbitmq 节点的类型有哪些？

- 磁盘节点：消息会存储到磁盘。
- 内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。
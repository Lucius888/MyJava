## 常见问题

### Mysql索引主要使用的两种数据结构

- 哈希索引，对于哈希索引来说，底层的数据结构肯定是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引
- B+Tree索引，Mysql的BTree索引使用的是B树中的B+Tree但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。

### 聚集索引和非聚集索引

**聚集索引**：索引中数据的物理存放地址和索引的顺序是一致的

**非聚集索引**：索引中数据的物理存放地址和索引的顺序是不一致的

### MyISAM和InnoDB实现BTree索引方式的区别

- InnoDB，其数据文件本身就是索引文件，树的节点data域保存了完整的数据记录。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）
- MyISAM，B+Tree叶节点的data域存放的是数据记录的地址，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读区相应的数据记录，因此myisam有两个文件（一个索引文件一个数据文件）。

### 为什么不用B树？

- B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；

- B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

- B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

### 为什么不用红黑树？

- 红黑树是一个二叉树，当数据量很大的时候树的深度会非常大，查找次数显著升高

- 数据库中使用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。而红黑树的每个节点都很小，造成浪费。

### 数据库引擎innodb与myisam的区别？

- 事务: InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键: InnoDB 支持外键。
- 备份: InnoDB 支持在线热备份。
- 崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性: MyISAM 支持压缩表和空间数据索引。

## ACID4大特性

### 举例

我们以从A账户转账50元到B账户为例进行说明一下ACID，四大特性。

### 原子性

事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

**如果无法保证原子性会怎么样？**

OK，就会出现**数据不一致**的情形，A账户减去50元，而B账户增加50元操作失败。系统将无故丢失50元~

#### Mysql怎么保证原子性的？

OK，是利用Innodb的`undo log`。 `undo log`名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。 例如

- (1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据
- (2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作
- (3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作

`undo log`记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。

### 一致性

数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

#### Mysql怎么保证一致性的？

OK，这个问题分为两个层面来说。 从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。

但是，如果你在事务里故意写出违反约束的代码，一致性还是无法保证的。例如，你在转账的例子中，你的代码里故意不给B账户加钱，那一致性还是无法保证。因此，还必须从应用层角度考虑。

### 隔离性

一个事务所做的修改在最终提交以前，对其它事务是不可见的。

#### Mysql怎么保证隔离性的？

OK,利用的是锁和MVCC机制。还是拿转账例子来说明，有一个账户表如下 表名`t_balance`

![](https://pic4.zhimg.com/80/v2-86bedce66efcc4a3b90d09740163e3a7_hd.jpg)

其中id是主键，user_id为账户名，balance为余额。还是以转账两次为例，如下图所示

![](https://pic2.zhimg.com/80/v2-9e136615fa9a741763dfc7ba2f976a99_hd.jpg)

至于MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据，这些快照数据在`undo log`中。 如果一个事务读取的行正在做DELELE或者UPDATE操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。 由于MVCC机制在可重复读(Repeateable Read)和读已提交(Read Commited)的MVCC表现形式不同，就不赘述了。

但是有一点说明一下，在事务隔离级别为读已提交(Read Commited)时，一个事务能够读到另一个事务已经提交的数据，是不满足隔离性的。但是当事务隔离级别为可重复读(Repeateable Read)中，是满足隔离性的。

### 持久性

持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

####  Mysql怎么保证持久性的？

是利用Innodb的`redo log`。 正如之前说的，Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。 *怎么解决这个问题？* 简单啊，事务提交前直接把数据写入磁盘就行啊。 *这么做有什么问题？*

- 只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。
- 毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。

于是，决定采用`redo log`解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在`redo log`中记录这次操作。当事务提交的时候，会将`redo log`日志进行刷盘(`redo log`一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将`redo log`中的内容恢复到数据库中，再根据`undo log`和`binlog`内容决定回滚数据还是提交数据。



### 并发事务带来的问题

#### 脏读

![](https://www.pdai.tech/_images/pics/dd782132-d830-4c55-9884-cfac0a541b8e.png)

#### 丢弃修改

T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最 终结果A=19，事务1的修改被丢失。

![](https://www.pdai.tech/_images/pics/88ff46b3-028a-4dbb-a572-1f062b8b96d3.png)

### 不可重复读

T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

![](https://www.pdai.tech/_images/pics/c8d18ca9-0b09-441a-9a0c-fb063630d708.png)

#### 幻读

T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

![](https://www.pdai.tech/_images/pics/72fe492e-f1cb-4cfc-92f8-412fb3ae6fec.png)

#### 不可重复度和幻读区别：

**不可重复读的重点是修改，幻读的重点在于新增或者删除。**

### 数据库的隔离级别

1. 读未提交，事务之间可以读取彼此未提交的数据 .**可能会导致脏读、幻读或不可重复读**.

    **读不会加任何锁。而写会加排他锁，并到事务结束之后释放。**（ 排他锁会阻止其它事务再对其**锁定的数据**加读或写的锁）

2. 读已经提交，事务之间可以读取彼此已提交的数据；**可以阻止脏读，但是幻读或不可重复读仍有可能发生**

3. 可重复读，就是对一个记录读取多次的记录是相同的，比如对于一个数A读取的话一直是A，前后两次读取的A是一致的；**可以阻止脏读和不可重复读，但幻读仍有可能发生。**

4. 可串行化读，在并发情况下，和串行化的读取的结果是一致的，没有什么不同，比如不会发生脏读和幻读；**该级别可以防止脏读、不可重复读以及幻读。** 全部的读写操作都会加锁，阻塞。

| 隔离级别         | 脏读 | 不可重复读 | 幻影读 |
| ---------------- | ---- | ---------- | ------ |
| READ-UNCOMMITTED | √    | √          | √      |
| READ-COMMITTED   | ×    | √          | √      |
| REPEATABLE-READ  | ×    | ×          | √      |
| SERIALIZABLE     | ×    | ×          | ×      |

**MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。**

- 使用MVCC解决不可重复读
- 这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别 下使用的是**间隙锁**，因此可以避免幻读的产生。
    - Next-Key Lock=间隙锁+行锁。
    - 间隙锁锁住的是一个范围，但不包括记录本身，间隙锁只工作在REPEATABLE-READ隔离级别之下。
    - Next-Key Lock锁定一个范围，并且锁定记录本身。**当查询的索引含有唯一属性（唯一索引，主键索引）时，Innodb存储引擎会对next-key lock进行优化，将其降为record lock,即仅锁住索引本身，而不是范围！若是普通辅助索引，则会使用传统的next-key lock进行范围锁定！**

InnoDB 存储引擎在 分布式事务 的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。

### MVCC（多版本并发控制）机制

**基本原理：**MVCC是通过保存数据在某个时间点的快照来实现该机制，这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据都是一致的。具体就是在其在每行记录后面保存两个隐藏的列，分别保存这个行的**创建版本号和删除版本号**，可以理解为事务id.

增：更新创建版本号为当前事务id

删：更新删除版本号为事务id

改：将原数据删除版本号更新为事务id，并且设置新的创建版本号

查：查找需要满足两个条件。当前事务版本号大于等于创建版本号（确保数据已存在），删除版本号为空或者大于当前事务版本号（确保数据未删除）。

## 内连接和外连接

内连接只显示符合连接条件的记录，外连接除了显示符合条件的记录外还会显示表中的记录。

### 内连接

- 内连接语句：

    ```select filedlist from table1 inner join table2 on table1.column =table2.column```

### 外连接

- 左外连接（LEFT OUTTER JOIN）
- 右外连接（RIGHT OUTTER JOIN）
- 全外连接（FULL OUTTER JOIN）

外连接语句

```select filedlist from table1 outer join table2 on table1.column =table2.column```

### 为什么使用索引？

- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 帮助服务器避免排序和临时表
- 将随机IO变为顺序IO
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

### 索引这么多优点，为什么不对表中的每一个列创建一个索引呢？

- 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
- 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立簇索引，那么需要的空间就会更大。
- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加

### 使用索引的注意事项？

- 在经常需要搜索的列上，可以加快搜索的速度；
- 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
- 在中到大型表索引都是非常有效的，但是特大型表的维护开销会很大，不适合建索引
- 避免where子句中对字段施加函数，这会造成无法命中索引
- 在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。
- **将打算加索引的列设置为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描**
- 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗
- 在使用limit offset查询缓存时，可以借助索引来提高性能。

### 主键索引和唯一索引的区别

- 主键索引是唯一索引的一种特殊类型
- 主键索引用于唯一标识表中的每一行，唯一索引则是不允许两行出现相同的索引值
- 主键索引不可为空，唯一索引可以
- 主键可以作为外键，唯一索引不行

### 索引失效的情况

- 违反最左前缀法则（即查询从索引的最左前列开始并且不跳过索引中的列）
- 在索引上做任何操作（比如计算，函数）
- 使用！=
- like后以通配符%开头
- 字符串不加单引号
- or连接

### count(1) count(*) count(列值)的区别

- count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL  

- count(*)包括了所有的列，相当于行数，在统计结果的时候，**不会忽略列值为NULL**  
- count(列名)只包括列名那一列，在统计结果的时候，**会忽略列值为NULL的计数**，即某个字段值为NULL时，不统计。

如果按照效率比较的话：

count(*)=count(1)>count(primary key)>count(column)

### 数据库结构优化

- 范式优化： 比如消除冗余（节省空间。。）
- 反范式优化：比如适当加冗余等（减少join）
- 限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时 候，我们可以控制在一个月的范围内。
- 读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；
- 拆分表：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。
- 拆分其实又分垂直拆分和水平拆分：
  - 案例： 简单购物系统暂设涉及如下表：
  - 1.产品表（数据量10w，稳定）
  - 2.订单表（数据量200w，且有增长趋势）
  - 3.用户表 （数据量100w，且有增长趋势）
  - 以mysql为例讲述下水平拆分和垂直拆分，mysql能容忍的数量级在百万静态数据可以到千万
  - **垂直拆分：**
    - 解决问题：表与表之间的io竞争
    - 不解决问题：单表中数据量增长出现的压力
    - 方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上
  - **水平拆分：**
    - 解决问题：单表中数据量增长出现的压力
    - 不解决问题：表与表之间的io争夺
  - 方案：**用户表** 通过性别拆分为男用户表和女用户表，**订单表** 通过已完成和完成中拆分为已完成订单和未完成订单，**产品表** 未完成订单放一个server上，已完成订单表盒男用户表放一个server上，女用户表放一个server上(女的爱购物 哈哈)。

### drop,delete与truncate的区别

drop直接删掉表;truncate删除表中数据，再插入时自增长id又从1开始 ;delete删除表中数据，可以加where字句。

1. DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。
2. 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。
3. 一般而言，drop > truncate > delete
4. 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view
5. TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。
6. truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。
7. delete语句为DML（Data Manipulation Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。
8.  truncate、drop是DDL（Data Define Language),操作立即生效，原数据不放到 rollback segment中，不能回滚
9. 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老是想触发trigger,还是用delete。
10. Truncate table 表名 速度快,而且效率高,因为: truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。
11. TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。
12. 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。

### 什么是覆盖索引?

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称 之为“覆盖索引”。我们知道在InnoDB存储引 擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次,这样就 会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！
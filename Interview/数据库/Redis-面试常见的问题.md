## 常见问题

### Redis是什么？

数据存在内存中也可持久化，使用单线程操作的一种key-value数据库。

### Redis优点

1. 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
2. 支持丰富数据类型，支持string，list，set，zset，hash
3. 可持久化，保证数据安全
4. 可集群
5. 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

### Redis为什么是单线程的？

因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。

### I/O多路复用

**多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态**，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。

![img](https://pic3.zhimg.com/80/v2-99c77dafd01970f9a60289bad5f3357b_720w.jpg?source=1940ef5c)

1. 客户端select机制 循环请求
2. 去请求服务端 询问是否可以read
3. 此时没有数据
4. 数据报准备完成
5. 服务端告诉客户端 可以read了 **（1~5 这个过程是阻塞的）**
6. 客户端发起read
7. 系统调用read
8. 复制数据报
9. 复制完成
10. 返回成功
11. 客户端 处理数据报

### Redis 常见数据结构以及使用场景分析

| 数据类型 | 结构存储的值                 | 常用命令                 | 使用场景                                       | 底层数据结构      |
| -------- | ---------------------------- | ------------------------ | ---------------------------------------------- | ----------------- |
| String   | 可以是字符串或数字           | GET/SET/DEL              | 存储 json 字符串；主键自增                     | int/raw/embstr    |
| Hash     | 包含键值对的无序散列表       | HSET/HGET/HDEL           | 存储对象类数据，如个人信息。相比string更加灵活 | ziplist/hashtable |
| List     | 一个可进行头尾增删的双向链表 | RPUSH/RPOP/LRANGE/RINDEX | 好友列表；最新内容                             | quickList         |
| Set      | 无序字符串                   | SADD/SMENBERS/SISMEMBER  | 共同好友：取交集                               | intSet/hashtable  |
| Zset     | 使用分值的概念有序保存元素   | ZADD/ZRANGE              | 基于共同好友，加上排序功能——好友排序           | ziplist/skiplist  |

## Redis过期时间

- 定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删 除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所 有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
- 惰性删除 ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这 就是所谓的惰性删除，也是够懒的哈！

## Redis内存淘汰机制

- voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
- volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
- allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
- no-enviction（驱逐）：禁止驱逐数据

## Redis持久化机制

#### RDB（snapshotting）持久化

**工作原理**

- Redis调用fork()，产生一个子进程。
- 子进程把数据写到一个临时的RDB文件。
- 当子进程写完新的RDB文件后，把旧的RDB文件替换掉。
- rdb触发机制可以自己设定

**优点**

- RDB的性能很好，需要进行持久化时，主进程会fork一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的I/O操作。
- 比起AOF，在数据量比较大的情况下，RDB的启动速度更快。
- RDB文件是一个很简洁的单文件，它保存了某个时间点的Redis数据，很适合用于做备份。

**缺点**

- RDB容易造成最后一次数据的丢失。
- RDB使用fork()产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成Redis停止服务几毫秒。

#### AOF（append-only ﬁle）持久化

**工作原理**

每当Redis接受到会修改数据集的命令时，就会把命令追加到AOF文件里，当你重启Redis时，AOF里的命令会被重新执行一次，重建数据。
		**优点**

- 比RDB可靠。默认是每秒同步一次。这意味着你最多丢失一秒钟的数据。
- AOF日志文件是一个纯追加的文件，文件的完整性会更好

**缺点**

- 在相同的数据集下，AOF文件的大小一般会比RDB文件大。
- AOF的速度会比RDB慢。

## Redis 事务

Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：

- 批量操作在发送 EXEC 命令前被放入队列缓存。
- 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。
- 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。

一个事务从开始到执行会经历以下三个阶段：

- 开始事务。（MUTI命令）
- 命令入队。
- 执行事务。（EXEC命令）

**单个 Redis 命令的执行是原子性的，但 Redis 事务不具有原子性**

## Redis 常见性能问题和解决方案

1. Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
2. 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
3. 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
4. 尽量避免在压力很大的主库上增加从库
5. 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3...

## redis高可用：Redis集群

### 主从复制

将一台Redis服务器的数据，复制到其他的Redis服务器。主机可以写，从机只能读。

**作用：**

- 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
- 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务
    的冗余。
- 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务
- 高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

### 同步机制（主从复制原理）

- Slave 启动成功连接到 master 后会发送一个sync同步命令。
- Master 接到命令，生成RDB文件并使用缓冲区记录此后执行的所有写命令。
- Master 发送RDB到Slaver，并开始发送缓存区中的写命令
- Slaver载入RDB，完成后执行来自Master缓存区中的写命令

以上过程就是一次**全量复制**，当slaver连接到master时必会发生一次全量复制。当连接后，master每执行一个写命令就会向slaver发送相同的写命令，slaver接收并执行收到的写命令。整个过程称为**增量复制**

### 哨兵模式

![img](https://img-blog.csdnimg.cn/20200515164428416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEyNTUwMg==,size_16,color_FFFFFF,t_70)

**主要功能**

- 主从运行情况检测
- 自动故障转移（选新的节点作为主节点）

**运行原理**

每个哨兵节点都需要 定期执行 以下任务：

- 每个 哨兵以 每秒钟 一次的频率，向它所知的 主、从服务器 以及其他 Sentinel 实例 发送一个 PING 命令。如果一段时间未收到回复就会被标记未主观下线
- 如果一个 主服务器 被标记为 主观下线，那么正在 监视 这个 主服务器 的所有 哨兵会确认该主服务器是否进入了主观下线。如果达到一定数量的哨兵认为该服务器已经主观下线就会将其标记为客观下线
- 哨兵通知下线服务器的从服务器已被下线并通过选举产生新的主节点。然后进行数据复制

**主观下线和客观下线**

- 主观下线：适用于所有 主节点 和 从节点。哨兵没有在规定时间内收到来自节点的回复就会判定该节点主观下线
- 客观下线：只适用于主节点。多个哨兵都判定其主观下线则为客观下线

## Redis穿透/击穿/雪崩

### 穿透

**缓存中没有这个值，请求全部直接涌向数据库**

**解决方法**

- 布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
- 如果一个查询返回的数据为空，我们仍然把这个空结果进行缓存，但它的过期时间会很短。这样第二次到缓存中获取就有值了，而不会继续访问数据库，

### 击穿

**热点key访问非常频繁，当这个 key 在缓存失效的瞬间，大量的请求就击穿了缓存，直接请求数据库**

**解决方法**

- 热点数据永不失效，有更新操作更新缓存就可以了

### 雪崩

**缓存集中过期或redis宕机，直接请求数据库**

**解决方法**

- 随机失效时间，防止缓存集中过期
- 数据预热

## 如何解决 Redis 的并发竞争 Key 问题

**分布式锁**或者zookeeper

**加锁操作的正确姿势为：**

1. 使用setnx命令保证互斥性
2. 设置锁的过期时间，避免死锁
3. setnx和设置过期时间需要保持原子性，避免在设置setnx成功之后在设置过期时间客户端崩溃导致死锁
4. 加锁的Value 值为一个唯一标示。可以采用UUID作为唯一标示。加锁成功后需要把唯一标示返回给客户端来用来客户端进行解锁操作

**解锁的正确姿势为：**

　　1. 需要拿加锁成功的唯一标示要进行解锁，从而保证加锁和解锁的是同一个客户端

　　2. 解锁操作需要比较唯一标示是否相等，相等再执行删除操作。

## 如何保证缓存与数据库的数据一致性？

https://coolshell.cn/articles/17416.html

### CAP(Cache Aside Pattern)

Redis是CP原则

读：命中缓存则直接返回，否则读数据库并写缓存

写：直接更新数据库，然后删除对应缓存。

### Read/Write Through Pattern

==**应用认为数据库和缓存是一体的**==

读：命中缓存直接返回，否则数据库更新缓存，然后返回

写：命中缓存则写缓存，然后由缓存写到数据库，**未命中则直接写数据库。**

![Write-through_with_no-write-allocation](https://coolshell.cn/wp-content/uploads/2016/07/460px-Write-through_with_no-write-allocation.svg_.png)




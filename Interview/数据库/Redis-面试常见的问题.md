## 常见问题

### Redis是什么？

数据存在内存中也可持久化，使用单线程操作的一种key-value数据库。

### Redis优点

1. 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
2. 支持丰富数据类型，支持string，list，set，sorted set，hash
3. 可持久化，保证数据安全
4. 可集群
5. 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

### 为什么要用Redis/为什么要用缓存？

1. **高性能**：假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！
2. **高并发**：直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。



### Redis为什么是单线程的？

因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。

### Redis相比memcached有哪些优势？

1. memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
2. redis的速度比memcached快很多
3. redis可以持久化其数据

### Redis 常见数据结构以及使用场景分析

#### String

> 常用命令: set,get,decr,incr,mget 等。

String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。

#### Hash

> 常用命令： hget,hset,hgetall 等。

Hash 是一个 string 类型的 ﬁeld 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅 仅修改这个对象中的某个字段的值。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。比如下面我就用 hash 类型存放了我本人的一些信息：

```json
key=JavaUser293847 
value={ “id”: 1, “name”: “SnailClimb”, “age”: 22, “location”: “Wuhan, Hubei” }
```

#### List

> 常用命令: lpush,rpush,lpop,rpop,lrange等

list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表， 消息列表等功能都可以用Redis的 list 结构来实现。

Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功 能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。

#### Set

> 常用命令： sadd,spop,smembers,sunion 等

set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。

当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在 一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。

比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常 方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：`sinterstore key1 key2 key3`将交集存在key1内

#### Sorted Set

> 常用命令： zadd,zrange,zrem,zcard等

和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。

举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维 度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。

## Redis过期时间

- 定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删 除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所 有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
- 惰性删除 ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这 就是所谓的惰性删除，也是够懒的哈！

## Redis内存淘汰机制

- voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
- volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
- allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
- no-enviction（驱逐）：禁止驱逐数据



## Redis持久化机制

#### RDB（snapshotting）持久化

**工作原理**

- Redis调用fork()，产生一个子进程。
- 子进程把数据写到一个临时的RDB文件。
- 当子进程写完新的RDB文件后，把旧的RDB文件替换掉。
- rdb触发机制可以自己设定

**优点**

- RDB的性能很好，需要进行持久化时，主进程会fork一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的I/O操作。
- 比起AOF，在数据量比较大的情况下，RDB的启动速度更快。
- RDB文件是一个很简洁的单文件，它保存了某个时间点的Redis数据，很适合用于做备份。

**缺点**

- RDB容易造成最后一次数据的丢失。
- RDB使用fork()产生子进程进行数据的持久化，如果数据比较大的话可能就会花费点时间，造成Redis停止服务几毫秒。

#### AOF（append-only ﬁle）持久化

**工作原理**

每当Redis接受到会修改数据集的命令时，就会把命令追加到AOF文件里，当你重启Redis时，AOF里的命令会被重新执行一次，重建数据。
		**优点**

- 比RDB可靠。默认是每秒同步一次。这意味着你最多丢失一秒钟的数据。
- AOF日志文件是一个纯追加的文件，文件的完整性会更好

**缺点**

- 在相同的数据集下，AOF文件的大小一般会比RDB文件大。
- AOF的速度会比RDB慢。

### Redis 事务

Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：

- 批量操作在发送 EXEC 命令前被放入队列缓存。
- 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。
- 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。

一个事务从开始到执行会经历以下三个阶段：

- 开始事务。（MUTI命令）
- 命令入队。
- 执行事务。（EXEC命令）

**单个 Redis 命令的执行是原子性的，但 Redis 事务不具有原子性**



### Redis 常见性能问题和解决方案

1. Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
2. 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
3. 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
4. 尽量避免在压力很大的主库上增加从库
5. 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3...

## Redis集群

### 主从复制

将一台Redis服务器的数据，复制到其他的Redis服务器。主机可以写，从机只能读。

**作用：**

- 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
- 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务
    的冗余。
- 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务
- 高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

### 同步机制（主从复制原理）

- Slave 启动成功连接到 master 后会发送一个sync同步命令。
- Master 接到命令，生成RDB文件并使用缓冲区记录此后执行的所有写命令。
- Master 发送RDB到Slaver，并开始发送缓存区中的写命令
- Slaver载入RDB，完成后执行来自Master缓存区中的写命令

以上过程就是一次**全量复制**，当slaver连接到master时必会发生一次全量复制。当连接后，master每执行一个写命令就会向slaver发送相同的写命令，slaver接收并执行收到的写命令。整个过程称为**增量复制**

### 哨兵模式

![img](https://img-blog.csdnimg.cn/20200515164428416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEyNTUwMg==,size_16,color_FFFFFF,t_70)

**主要功能**

- 主从运行情况检测
- 自动故障转移（选新的节点作为主节点）

**运行原理**

每个哨兵节点都需要 定期执行 以下任务：

- 每个 哨兵以 每秒钟 一次的频率，向它所知的 主、从服务器 以及其他 Sentinel 实例 发送一个 PING 命令。如果一段时间未收到回复就会被标记未主观下线
- 如果一个 主服务器 被标记为 主观下线，那么正在 监视 这个 主服务器 的所有 哨兵会确认该主服务器是否进入了主观下线。如果达到一定数量的哨兵认为该服务器已经主观下线就会将其标记为客观下线
- 哨兵通知下线服务器的从服务器已被下线并通过选举产生新的主节点。然后进行数据复制

**主观下线和客观下线**

- 主观下线：适用于所有 主节点 和 从节点。哨兵没有在规定时间内收到来自节点的回复就会判定该节点主观下线
- 客观下线：只适用于主节点。多个哨兵都判定其主观下线则为客观下线

## Redis穿透/击穿/雪崩

### 穿透

**缓存中没有这个值，请求全部直接涌向数据库**

**解决方法**

- 布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
- 如果一个查询返回的数据为空（，我们仍然把这个空结果进行缓存，但它的过期时间会很短。这样第二次到缓存中获取就有值了，而不会继续访问数据库，

### 击穿

**热点key访问非常频繁，当这个 key 在缓存失效的瞬间，大量的请求就击穿了缓存，直接请求数据库**

**解决方法**

- 热点数据永不失效，有更新操作更新缓存就可以了

### 雪崩

**缓存集中过期或redis宕机，直接请求数据库**

**解决方法**

- 随机失效时间，防止缓存集中过期
- 数据预热

## 如何解决 Redis 的并发竞争 Key 问题

**分布式锁**或者zookeeper

**加锁操作的正确姿势为：**

1. 使用setnx命令保证互斥性
2. 设置锁的过期时间，避免死锁
3. setnx和设置过期时间需要保持原子性，避免在设置setnx成功之后在设置过期时间客户端崩溃导致死锁
4. 加锁的Value 值为一个唯一标示。可以采用UUID作为唯一标示。加锁成功后需要把唯一标示返回给客户端来用来客户端进行解锁操作

**解锁的正确姿势为：**

　　1. 需要拿加锁成功的唯一标示要进行解锁，从而保证加锁和解锁的是同一个客户端

　　2. 解锁操作需要比较唯一标示是否相等，相等再执行删除操作。

## 如何保证缓存与数据库的数据一致性？

https://coolshell.cn/articles/17416.html

![Write-through_with_no-write-allocation](https://coolshell.cn/wp-content/uploads/2016/07/460px-Write-through_with_no-write-allocation.svg_.png)

### CAP(Cache Aside Pattern)

读：命中缓存则直接返回，否则读数据库并写缓存

写：直接更新数据库，然后删除对应缓存。

### Read/Write Through Pattern

==**应用认为数据库和缓存是一体的**==

读：命中缓存直接返回，否则数据库更新缓存，然后返回

写：命中缓存则写缓存，然后由缓存写到数据库，未命中则直接写缓存。


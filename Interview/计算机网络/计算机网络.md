### 1.五层协议


- **1. 应用层**

应用层（application-layer）的任务是**通过应用进程间的交互来完成特定网络应用**。应用层协议定义的是应用进程间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。

- **2. 运输层**

运输层（transport layer）的主要任务就是**负责向两台主机进程之间的通信提供通用的数据传输服务**。应用进程利用该服务传送应用层报文。**TCP/UDP**

由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。

- **3. 网络层**

在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于网络层使用 **IP 协议**，因此分组也叫 IP 数据报，简称数据报。 

- **4. 数据链路层**

网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。**数据链路层把网络层传下来的分组封装成帧。**

- **5. 物理层**

物理层（physical layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层感觉不到这些差异。

### 2.UDP和TCP的特点

- **传输控制协议 TCP**（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流，每一条 TCP 连接只能是点对点的（一对一）。
- - **TCP 可靠性**
        - 超时重传：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。
        - 流量控制：控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。
        - 拥塞控制：TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。
- **用户数据报协议 UDP**（User Datagram Protocol）是无连接的，尽最大可能交付，面向报文，没有拥塞控制，支持一对一、一对多、多对一和多对多的交互通信。

### 3.TCP的三次握手和四次挥手

**TCP首部的关键字：**

- 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。
- 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- 终止 FIN ：用来释放一个连接，当 FIN=1 时表示此报文段的发送方的数据已发送完毕，并要求释放连接

#### 3.1 三次握手

<img src="F:\GithubFile\MyJava\Interview\picture\Image.png" style="zoom: 33%;" />


假设 A 为客户端，B 为服务器端。
- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。

**三次握手的原因：**

为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。比如下面这种情况：A 发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达 B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就误认为 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。

此时如果不进行第三次握手，B 发出确认后就认为新的运输连接已经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。

如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。

**为什么不需要四次握手？**

有人可能会说 A 发出第三次握手的信息后在没有接收到 B 的请求就已经进入了连接状态，那如果 A 的这个确认包丢失或者滞留了怎么办？

我们需要明白一点，完全可靠的通信协议是不存在的。在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。

#### 3.2 四次挥手
<img src="F:\GithubFile\MyJava\Interview\picture\Image [2].png" style="zoom: 50%;" />

- A 发送连接释放报文，FIN=1。
- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，发送连接释放报文，FIN=1。
- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
- B 收到 A 的确认后释放连接。

**四次挥手的原因：**

这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。
&emsp;&emsp;**TIME_WAIT**

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

## 状态码

| 1xx  | 信息性状态码       | 请求正在处理               |
| ---- | ------------------ | -------------------------- |
| 2xx  | 成功状态码         | 请求处理成功               |
| 3xx  | 重定向状态码       | 需要进行附加操作以完成请求 |
| 4xx  | 客户端错误状态码   | 服务器无法处理请求         |
| 5xx  | 服务器端错误状态码 | 服务器请求出错             |

### get 和 post 请求有哪些区别？

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET请求在URL中传送的参数是有长度和类型限制的，而POST么有。
- GET请求参数会被完整保留在浏览器历史记录里，POST不会被保留。
- GET请求只能进行url编码，而POST支持多种编码方式。

### 一次http请求的全过程

1. 对请求网址进行DNS域名解析，得到对应的IP地址
2. 根据这个IP，找到对应的服务器，发起TCP的三次握手
3. 建立TCP连接后发起HTTP请求
4. 服务器响应HTTP请求，浏览器得到html代码
5. 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）
6. 浏览器对页面进行渲染呈现给用户
7. 服务器关闭TCP连接

## TCP和Http的区别与联系

- Tcp是传输层协议，**定义数据传输和连接方式的规范**
- HTTP是应用层协议，**定义传输数据内容的规范**
- Http中的数据是利用tcp协议进行传输的，好比网络是路，tcp就是车，http就是车上的人。

## HTTP 和 HTTPS 的区别？

HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范

- **端口** ：HTTP的URL默认使用端口**80**，而HTTPS的URL默认使用端口**443**。

- **安全性和资源消耗**：

    HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。

    - 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
    - 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等

## http1.0,1.1和2.0的区别

### HTTP1.1 的主要变化

- 1.1 提出长连接，HTTP 可以在一次 TCP 连接中不断发送请求。
- 然后 HTTP1.1 支持只发送 header 而不发送 body。原因是先用 header 判断能否成功，再发数据，节约带宽，事实上，post 请求默认就是这样做的。
- HTTP1.1 的 host 字段。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到 host。

### HTTP2.0 的主要变化：

-  HTTP2.0 支持多路复用，同一个连接可以并发处理多个请求，方法是把 HTTP数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个 HTTP请求顺序到达；
- HTTP2.0 支持服务端推送，就是服务端在 HTTP 请求到达后，除了返回数据之外，还推送了额外的内容给客户端；
- HTTP2.0 压缩了请求头，同时基本单位是二进制帧流，这样的数据占用空间更少；
- HTTP2.0 适用于 HTTPS 场景，因为其在 HTTP和 TCP 中间加了一层 SSL 层。





https://blog.csdn.net/pcwl1206/article/details/103959802